"""
Test LLM-generated state machine examples.
This test validates the parser against real examples generated by Claude and GPT.
"""
import os
from mermaid_parser.converters.state_diagram import StateDiagramConverter


def load_mermaid_file(filename):
    """Load a mermaid file from the tests/assets directory."""
    # Get the directory of this test file
    test_dir = os.path.dirname(os.path.abspath(__file__))
    filepath = os.path.join(test_dir, 'assets', filename)
    with open(filepath, 'r') as f:
        return f.read()


def test_claude_breadmaker():
    """Test Claude's bread maker state machine."""
    print("\n" + "="*80)
    print("Testing: claude-breadMaker.mmd")
    print("="*80)

    mermaid_text = load_mermaid_file("claude-breadMaker.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, 'id_', None)
        parent_id = getattr(state, 'parent_id', None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if '_start' not in str(state_id) and '_end' not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    print(f"\n✅ Parsed successfully")
    print(f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}")
    print(f"Total transitions: {len(result.transitions)}")

    print(f"\nState hierarchy:")
    for parent in sorted(states_by_parent.keys(), key=lambda x: (x is not None, str(x))):
        children = sorted(states_by_parent[parent])
        if parent is None:
            print(f"  Root: {children}")
        else:
            print(f"  {parent}: {children}")

    # Check for expected states
    expected_states = ['Off', 'On', 'Configuration', 'BakingProcess',
                      'CourseSelection', 'CrustSelection', 'TimerSetting',
                      'Kneading', 'Rising', 'Baking', 'Warming']

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"

    return result


def test_gpt_breadmaker():
    """Test GPT's bread maker state machine."""
    print("\n" + "="*80)
    print("Testing: GPT-breadMaker.mmd")
    print("="*80)

    mermaid_text = load_mermaid_file("GPT-breadMaker.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, 'id_', None)
        parent_id = getattr(state, 'parent_id', None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if '_start' not in str(state_id) and '_end' not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    print(f"\n✅ Parsed successfully")
    print(f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}")
    print(f"Total transitions: {len(result.transitions)}")

    print(f"\nState hierarchy:")
    for parent in sorted(states_by_parent.keys(), key=lambda x: (x is not None, str(x))):
        children = sorted(states_by_parent[parent])
        if parent is None:
            print(f"  Root: {children}")
        else:
            print(f"  {parent}: {children}")

    # Check for expected states
    expected_states = ['Off', 'On', 'CourseSelection', 'CrustSelection',
                      'TimerSetting', 'BakingProcess', 'Countdown',
                      'Kneading', 'Rising', 'Baking', 'Warming']

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"

    return result


def test_claude_spamanager():
    """Test Claude's spa manager state machine."""
    print("\n" + "="*80)
    print("Testing: claude-spamanager.mmd")
    print("="*80)

    mermaid_text = load_mermaid_file("claude-spamanager.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, 'id_', None)
        parent_id = getattr(state, 'parent_id', None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if '_start' not in str(state_id) and '_end' not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    print(f"\n✅ Parsed successfully")
    print(f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}")
    print(f"Total transitions: {len(result.transitions)}")

    print(f"\nState hierarchy:")
    for parent in sorted(states_by_parent.keys(), key=lambda x: (x is not None, str(x))):
        children = sorted(states_by_parent[parent])
        if parent is None:
            print(f"  Root: {children}")
        else:
            print(f"  {parent}: {children}")

    # Check for expected parallel regions
    expected_states = ['SpaSystem', 'Sauna', 'Jacuzzi', 'SaunaOn', 'JacuzziOn']

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"

    return result


def test_gpt_spamanager():
    """Test GPT's spa manager state machine."""
    print("\n" + "="*80)
    print("Testing: GPT-spamanager.mmd")
    print("="*80)

    mermaid_text = load_mermaid_file("GPT-spamanager.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, 'id_', None)
        parent_id = getattr(state, 'parent_id', None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if '_start' not in str(state_id) and '_end' not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    print(f"\n✅ Parsed successfully")
    print(f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}")
    print(f"Total transitions: {len(result.transitions)}")

    print(f"\nState hierarchy:")
    for parent in sorted(states_by_parent.keys(), key=lambda x: (x is not None, str(x))):
        children = sorted(states_by_parent[parent])
        if parent is None:
            print(f"  Root: {children}")
        else:
            print(f"  {parent}: {children}")

    # Check for expected parallel regions
    expected_states = ['SpaManager', 'Sauna', 'Jacuzzi']

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"

    return result


def test_claude_dishwasher():
    """Test Claude's dishwasher state machine."""
    print("\n" + "="*80)
    print("Testing: claude-dishwasher.mmd")
    print("="*80)

    mermaid_text = load_mermaid_file("claude-dishwasher.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, 'id_', None)
        parent_id = getattr(state, 'parent_id', None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if '_start' not in str(state_id) and '_end' not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    print(f"\n✅ Parsed successfully")
    print(f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}")
    print(f"Total transitions: {len(result.transitions)}")

    print(f"\nState hierarchy:")
    for parent in sorted(states_by_parent.keys(), key=lambda x: (x is not None, str(x))):
        children = sorted(states_by_parent[parent])
        if parent is None:
            print(f"  Root: {children}")
        else:
            print(f"  {parent}: {children}")

    # Check for expected states
    expected_states = ['ProgramSelection', 'Running', 'Drying', 'ProgramComplete']

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"

    return result


def test_gpt_dishwasher():
    """Test GPT's dishwasher state machine."""
    print("\n" + "="*80)
    print("Testing: GPT-Dishwasher.mmd")
    print("="*80)

    mermaid_text = load_mermaid_file("GPT-Dishwasher.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, 'id_', None)
        parent_id = getattr(state, 'parent_id', None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if '_start' not in str(state_id) and '_end' not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    print(f"\n✅ Parsed successfully")
    print(f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}")
    print(f"Total transitions: {len(result.transitions)}")

    print(f"\nState hierarchy:")
    for parent in sorted(states_by_parent.keys(), key=lambda x: (x is not None, str(x))):
        children = sorted(states_by_parent[parent])
        if parent is None:
            print(f"  Root: {children}")
        else:
            print(f"  {parent}: {children}")

    # Check for expected states
    expected_states = ['Idle', 'Active', 'Drying', 'Suspended']

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"

    return result


def run_all_tests():
    """Run all LLM-generated example tests."""
    print("\n" + "="*80)
    print("TESTING ALL LLM-GENERATED STATE MACHINE EXAMPLES")
    print("="*80)

    tests = [
        ("claude-breadMaker", test_claude_breadmaker),
        ("GPT-breadMaker", test_gpt_breadmaker),
        ("claude-spamanager", test_claude_spamanager),
        ("GPT-spamanager", test_gpt_spamanager),
        ("claude-dishwasher", test_claude_dishwasher),
        ("GPT-Dishwasher", test_gpt_dishwasher),
    ]

    results = {}
    for name, test_func in tests:
        try:
            test_func()
            results[name] = "✅ PASS"
        except Exception as e:
            results[name] = f"❌ FAIL: {e}"
            import traceback
            traceback.print_exc()

    # Summary
    print("\n" + "="*80)
    print("TEST SUMMARY")
    print("="*80)
    for name, result in results.items():
        print(f"{name}: {result}")

    passed = sum(1 for r in results.values() if "PASS" in r)
    total = len(results)
    print(f"\n{passed}/{total} tests passed")

    return all("PASS" in r for r in results.values())


if __name__ == "__main__":
    success = run_all_tests()
    exit(0 if success else 1)
