"""
Test LLM-generated state machine examples.
This test validates the parser against real examples generated by Claude and GPT.
"""

import os
from mermaid_parser.converters.state_diagram import StateDiagramConverter
from loguru import logger


def load_mermaid_file(filename):
    """Load a mermaid file from the tests/assets directory."""
    # Get the directory of this test file
    test_dir = os.path.dirname(os.path.abspath(__file__))
    filepath = os.path.join(test_dir, "assets", filename)
    with open(filepath, "r") as f:
        return f.read()


def test_claude_breadmaker():
    """Test Claude's bread maker state machine."""
    logger.debug("\n" + "=" * 80)
    logger.debug("Testing: claude-breadMaker.mmd")
    logger.debug("=" * 80)

    mermaid_text = load_mermaid_file("claude-breadMaker.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, "id_", None)
        parent_id = getattr(state, "parent_id", None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if "_start" not in str(state_id) and "_end" not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    logger.debug("\n✅ Parsed successfully")
    logger.debug(
        f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}"
    )
    logger.debug(f"Total transitions: {len(result.transitions)}")

    logger.debug("\nState hierarchy:")
    for parent in sorted(
        states_by_parent.keys(), key=lambda x: (x is not None, str(x))
    ):
        children = sorted(states_by_parent[parent])
        if parent is None:
            logger.debug(f"  Root: {children}")
        else:
            logger.debug(f"  {parent}: {children}")

    # Check for expected states
    expected_states = [
        "Off",
        "On",
        "Configuration",
        "BakingProcess",
        "CourseSelection",
        "CrustSelection",
        "TimerSetting",
        "Kneading",
        "Rising",
        "Baking",
        "Warming",
    ]

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"


def test_gpt_breadmaker():
    """Test GPT's bread maker state machine."""
    logger.debug("\n" + "=" * 80)
    logger.debug("Testing: GPT-breadMaker.mmd")
    logger.debug("=" * 80)

    mermaid_text = load_mermaid_file("GPT-breadMaker.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, "id_", None)
        parent_id = getattr(state, "parent_id", None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if "_start" not in str(state_id) and "_end" not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    logger.debug("\n✅ Parsed successfully")
    logger.debug(
        f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}"
    )
    logger.debug(f"Total transitions: {len(result.transitions)}")

    logger.debug("\nState hierarchy:")
    for parent in sorted(
        states_by_parent.keys(), key=lambda x: (x is not None, str(x))
    ):
        children = sorted(states_by_parent[parent])
        if parent is None:
            logger.debug(f"  Root: {children}")
        else:
            logger.debug(f"  {parent}: {children}")

    # Check for expected states
    expected_states = [
        "Off",
        "On",
        "CourseSelection",
        "CrustSelection",
        "TimerSetting",
        "BakingProcess",
        "Countdown",
        "Kneading",
        "Rising",
        "Baking",
        "Warming",
    ]

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"


def test_claude_spamanager():
    """Test Claude's spa manager state machine."""
    logger.debug("\n" + "=" * 80)
    logger.debug("Testing: claude-spamanager.mmd")
    logger.debug("=" * 80)

    mermaid_text = load_mermaid_file("claude-spamanager.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, "id_", None)
        parent_id = getattr(state, "parent_id", None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if "_start" not in str(state_id) and "_end" not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    logger.debug("\n✅ Parsed successfully")
    logger.debug(
        f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}"
    )
    logger.debug(f"Total transitions: {len(result.transitions)}")

    logger.debug("\nState hierarchy:")
    for parent in sorted(
        states_by_parent.keys(), key=lambda x: (x is not None, str(x))
    ):
        children = sorted(states_by_parent[parent])
        if parent is None:
            logger.debug(f"  Root: {children}")
        else:
            logger.debug(f"  {parent}: {children}")

    # Check for expected parallel regions
    expected_states = ["SpaSystem", "Sauna", "Jacuzzi", "SaunaOn", "JacuzziOn"]

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"


def test_gpt_spamanager():
    """Test GPT's spa manager state machine."""
    logger.debug("\n" + "=" * 80)
    logger.debug("Testing: GPT-spamanager.mmd")
    logger.debug("=" * 80)

    mermaid_text = load_mermaid_file("GPT-spamanager.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, "id_", None)
        parent_id = getattr(state, "parent_id", None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if "_start" not in str(state_id) and "_end" not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    logger.debug("\n✅ Parsed successfully")
    logger.debug(
        f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}"
    )
    logger.debug(f"Total transitions: {len(result.transitions)}")

    logger.debug("\nState hierarchy:")
    for parent in sorted(
        states_by_parent.keys(), key=lambda x: (x is not None, str(x))
    ):
        children = sorted(states_by_parent[parent])
        if parent is None:
            logger.debug(f"  Root: {children}")
        else:
            logger.debug(f"  {parent}: {children}")

    # Check for expected parallel regions
    expected_states = ["SpaManager", "Sauna", "Jacuzzi"]

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"


def test_claude_dishwasher():
    """Test Claude's dishwasher state machine."""
    logger.debug("\n" + "=" * 80)
    logger.debug("Testing: claude-dishwasher.mmd")
    logger.debug("=" * 80)

    mermaid_text = load_mermaid_file("claude-dishwasher.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, "id_", None)
        parent_id = getattr(state, "parent_id", None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if "_start" not in str(state_id) and "_end" not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    logger.debug("\n✅ Parsed successfully")
    logger.debug(
        f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}"
    )
    logger.debug(f"Total transitions: {len(result.transitions)}")

    logger.debug("\nState hierarchy:")
    for parent in sorted(
        states_by_parent.keys(), key=lambda x: (x is not None, str(x))
    ):
        children = sorted(states_by_parent[parent])
        if parent is None:
            logger.debug(f"  Root: {children}")
        else:
            logger.debug(f"  {parent}: {children}")

    # Check for expected states
    expected_states = ["ProgramSelection", "Running", "Drying", "ProgramComplete"]

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"


def test_gpt_dishwasher():
    """Test GPT's dishwasher state machine."""
    logger.debug("\n" + "=" * 80)
    logger.debug("Testing: GPT-Dishwasher.mmd")
    logger.debug("=" * 80)

    mermaid_text = load_mermaid_file("GPT-Dishwasher.mmd")
    converter = StateDiagramConverter()
    result = converter.convert(mermaid_text)

    # Analyze hierarchy
    states_by_id = {}
    states_by_parent = {}

    for state in result.states:
        state_id = getattr(state, "id_", None)
        parent_id = getattr(state, "parent_id", None)

        if state_id:
            states_by_id[state_id] = state
            if parent_id not in states_by_parent:
                states_by_parent[parent_id] = []
            if "_start" not in str(state_id) and "_end" not in str(state_id):
                states_by_parent[parent_id].append(state_id)

    logger.debug("\n✅ Parsed successfully")
    logger.debug(
        f"Total states: {len([s for s in result.states if hasattr(s, 'id_') and '_start' not in str(s.id_)])}"
    )
    logger.debug(f"Total transitions: {len(result.transitions)}")

    logger.debug("\nState hierarchy:")
    for parent in sorted(
        states_by_parent.keys(), key=lambda x: (x is not None, str(x))
    ):
        children = sorted(states_by_parent[parent])
        if parent is None:
            logger.debug(f"  Root: {children}")
        else:
            logger.debug(f"  {parent}: {children}")

    # Check for expected states
    expected_states = ["Idle", "Active", "Drying", "Suspended"]

    for expected in expected_states:
        assert expected in states_by_id, f"Expected state '{expected}' not found"
